/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic startup code for a Juce application.

  ==============================================================================
*/

#include "../JuceLibraryCode/AppConfig.h"
#include "juce_StandaloneFilterWindow.h"
#include "../../Source/Synth.h"
static inline float protection_clipping_v2( float input_and_worker_ )
{
    if( input_and_worker_ > HARD_CLIPPER_STAGE_1 )
    {
        input_and_worker_ = HARD_CLIPPER_STAGE_1 + input_and_worker_*0.1f;
        if( input_and_worker_ > HARD_CLIPPER_STAGE_2 )
        {
            input_and_worker_ = HARD_CLIPPER_STAGE_2 + input_and_worker_*0.05f;
            if( input_and_worker_ > HARD_CLIPPER_STAGE_2 )
            {
                input_and_worker_ = HARD_CLIPPER_STAGE_2;
            }
        }
    }
    else if( input_and_worker_ < -HARD_CLIPPER_STAGE_1 )
    {
        input_and_worker_ = -HARD_CLIPPER_STAGE_1 + input_and_worker_*0.1f;
        if( input_and_worker_ < -HARD_CLIPPER_STAGE_2 )
        {
            input_and_worker_ = -HARD_CLIPPER_STAGE_2 + input_and_worker_*0.05f;
            if( input_and_worker_ < -HARD_CLIPPER_STAGE_2 )
            {
                input_and_worker_ = -HARD_CLIPPER_STAGE_2;
            }
        }
    }

    return input_and_worker_;
}
#define FIRST_DIMENSION_SIZE 500000
float** __source;
float** __target;
float** __arrays;
float* __tmp_array;

NOINLINE float test_function( float f1 ) {
    return (f1*1.1f + f1*1.23f) * (f1/1.27f);
}

NOINLINE float haevy_loop_with_own_memory( float** buffer_to_fill_, float** source_, int DIMENSION_SIZE /*to avoid optimisations*/)
{
    // TODO check with new alocation
    float* arr = new float[DIMENSION_SIZE];

    // FILL
    for( int f1 = 0 ; f1 != DIMENSION_SIZE ; ++f1 )
    {
        for( int f2 = 0 ; f2 != DIMENSION_SIZE ; ++f2 )
        {
            arr[f2] = test_function(f2*source_[f1][f2]);
        }
    }

    // TEST
    for( int f1 = 0 ; f1 != DIMENSION_SIZE ; ++f1 )
    {
        for( int f2 = 0 ; f2 != DIMENSION_SIZE ; ++f2 )
        {
            arr[f2] = test_function(arr[f2]*source_[f1][f2]);
        }
    }

    // WRITE OUT
    // HERE WE CAN TEST ++ iterations
    for( int f1 = 0 ; f1 != DIMENSION_SIZE ; ++f1 )
    {
        for( int f2 = 0 ; f2 != DIMENSION_SIZE ; ++f2 )
        {
            buffer_to_fill_[f1][f2] = arr[f2];
        }
    }
}
/*
float haevy_loop_with_own_one_dimension_size()
{
    float arrays[SECOND_DIMENSION_SIZE];

    for( int f1 = 0 ; f1 != FIRST_DIMENSION_SIZE ; ++f1 )
    {
        for( int f2 = 0 ; f2 != SECOND_DIMENSION_SIZE ; ++f2 )
        {
	    arrays[f1][f2] = test_function(f1,f2);
        }
    }
}
*/
NOINLINE float haevy_loop_wirting_to_static_arrays( float** buffer_to_fill_, float** source_, int DIMENSION_SIZE /*to avoid optimisations*/) {
    // FILL
    for( int f1 = 0 ; f1 != DIMENSION_SIZE ; ++f1 )
    {
        for( int f2 = 0 ; f2 != DIMENSION_SIZE ; ++f2 )
        {
            __tmp_array[f2] = test_function(f2*source_[f1][f2]);
        }
    }

    // TEST
    for( int f1 = 0; f1 != DIMENSION_SIZE ; ++f1 )
    {
        for( int f2 = 0 ; f2 != DIMENSION_SIZE ; ++f2 )
        {
            __tmp_array[f2] = test_function(__tmp_array[f2]*source_[f1][f2]);
        }
    }

    // WRITE OUT
    // HERE WE CAN TEST ++ iterations
    for( int f1 = 0 ; f1 != DIMENSION_SIZE ; ++f1 )
    {
        for( int f2 = 0 ; f2 != DIMENSION_SIZE ; ++f2 )
        {
            buffer_to_fill_[f1][f2] = __tmp_array[f2];
        }
    }
}
// SAME LOOP LIKE THE FIRST ONE, BUT USING tmp_array
NOINLINE float haevy_loop_with_writing_in_a_static_tmp_array(float** buffer_to_fill_, float** source_, int DIMENSION_SIZE /*to avoid optimisations*/ ) {

}
float haevy_loop_with_tweaked_iteration() {

}
float do_something_with_the_static_arrays() {

}

//RESUME es kann optimiert werden was zur laufzeit bekannt ist
//i * i
// bis 64x64 lässt sich gut optimieren
// auch 512x64 lässt sich gut optimieren
// auch mit unheimlichen gössen
// und auch wenn der inhalt der arrays nicht bekannt ist
// mit dem sample offset kaum
// geht doch
// -mavx optimize that cool stuff out. anyway, maybe you can try it for your array
#define THIS_TEST_T 512
float* Looped_array;
float* Looped_array2;
float* Looped_array3;
float* Looped_array4;
float* Looped_array5;
float** Looped_array_31;
float** Looped_array_3;

#define EXECUTE_UNROLL_3

struct Looped {
    NOINLINE static void unroll3( int block_size_, float** target_ ) {
        for( int i = 0 ; i != 512 ; ++i )
        {
#define UNROLL_3(x3) \
   target_[x3][i] = target_[x3][i]*target_[x3][i]

#include "../../Source/loop_execute.h"
        }
    }
    NOINLINE static void process3( int block_size_, float** target_ ) {
        for( int i = 0 ; i != 512 ; ++i )
        {
            for( int j = 0 ; j != 3 ; ++j )
                target_[j][i] = target_[j][i]*target_[j][i];
        }
    }

    NOINLINE static void process_noral( int block_size_, float* target_ ) {
        for( int i = 0 ; i != block_size_ ; ++i )
        {
            target_[i] = target_[i]*target_[i];
        }

        for( int i = 0 ; i != 512 ; ++i ) {
            target_[i] = target_[i] * target_[i];
        }
    }

    // schnell mit sample offset
    template<int size>
    static void process_template_( int sample_offset_, float* target_ ) {
        for( int i = 0 ; i != size ; ++i )
        {
            // NICHT SCHNELL!!!
            //target_[sample_offset_+i] =target_[i]*target_[sample_offset_+i];

            target_[sample_offset_+i] =target_[i]*target_[sample_offset_+i];
        }
    }
    template<int size, int sample_offset_>
    static void process_template_v2( float* target_ ) {
        for( int i = 0 ; i != size ; ++i )
        {
            // AUCH SCHNELL
            //target_[sample_offset_+i] =target_[i]*target_[sample_offset_+i];

            target_[sample_offset_+i] =target_[sample_offset_+i]*target_[sample_offset_+i];
        }
    }
    template<int size, int sample_offset_>
    static void process_template_v3( float* target_ ) {
        for( int i = 0 ; i != size ; ++i )
        {
            target_[sample_offset_+i] =target_[sample_offset_+i]*target_[sample_offset_+i];
        }
    }
    // schnell mit sample offset
    NOINLINE static void process_template_v2( int block_size_, float* target_ ) {
        process_template_v2<64,64*0>(target_);
        process_template_v2<64,64*1>(target_);
        process_template_v2<64,64*2>(target_);
        process_template_v2<64,64*3>(target_);
        process_template_v2<64,64*4>(target_);
        process_template_v2<64,64*5>(target_);
        process_template_v2<64,64*6>(target_);
        process_template_v2<64,64*7>(target_);

        //IST AUCH DEUTLICH SCHNELLER ALS IN EINEM 512er LOOP
        int i = 0;
        while( i < 512 ) {
            *target_ = *target_ * *target_;
            ++target_;
            ++i;
        }
    }
    NOINLINE static void process_template_v2b( int block_size_, float* target_ ) {
        static float* target___ = new float[512];
        process_template_v2<64,64*0>(target_);
        process_template_v2<64,64*1>(target_);
        process_template_v2<64,64*2>(target_);
        process_template_v2<64,64*3>(target_);
        process_template_v2<64,64*4>(target_);
        process_template_v2<64,64*5>(target_);
        process_template_v2<64,64*6>(target_);
        process_template_v2<64,64*7>(target_);

        //IST AUCH DEUTLICH SCHNELLER ALS IN EINEM 512er LOOP
        // LÄST SICH BESSER SCHREIBEN ALS OBEN
        for( int i = 0 ; i != 64 ; ++i ) {
            int ii = 8*i;
            target_[ii+0] = target_[ii+0] * target_[ii+0];
            target_[ii+1] = target_[ii+1] * target_[ii+1];
            target_[ii+2] = target_[ii+2] * target_[ii+2];
            target_[ii+3] = target_[ii+3] * target_[ii+3];
            target_[ii+4] = target_[ii+4] * target_[ii+4];
            target_[ii+5] = target_[ii+5] * target_[ii+5];
            target_[ii+6] = target_[ii+6] * target_[ii+6];
            target_[ii+7] = target_[ii+7] * target_[ii+7];
        }
    }
    // OWN MEMORY IST NICHT SCHNELLER
    // auch nicht in rauen mengen
    NOINLINE static void process_template_own_memory( int block_size_, float* target_ ) {
        static float* target___ = new float[512];
        process_template_v3<64,64*0>(target___);
        process_template_v3<64,64*1>(target___);
        process_template_v3<64,64*2>(target___);
        process_template_v3<64,64*3>(target___);
        process_template_v3<64,64*4>(target___);
        process_template_v3<64,64*5>(target___);
        process_template_v3<64,64*6>(target___);
        process_template_v3<64,64*7>(target___);

        for( int i = 0 ; i != 512 ; ++i ) {
            target_[i] = target___[i] * target___[i];
        }
    }
    NOINLINE static void process_template( int block_size_, float* target_ ) {
        if( block_size_ == 512 )
            for( int i = 0 ; i != 8 ; ++i )
            {
                process_template_<64>(64*i, target_);
            }
        else if ( block_size_ == THIS_TEST_T ) {
            for( int i = 0 ; i != (THIS_TEST_T) / 64 ; ++i )
            {
                process_template_<64>(64*i, target_);
            }
        }

        for( int i = 0 ; i != 512 ; ++i ) {
            target_[i] = target_[i] * target_[i];
        }
    }
    /*
            process_template_<64>(64*0, target_);
            process_template_<64>(64*1, target_);
            process_template_<64>(64*2, target_);
            process_template_<64>(64*3, target_);
            process_template_<64>(64*4, target_);
            process_template_<64>(64*5, target_);
            process_template_<64>(64*6, target_);
            process_template_<64>(64*7, target_);

            */

};


//==============================================================================
class gstepstandaloneApplication  : public JUCEApplication, public Timer
{
public:
    //==============================================================================
    gstepstandaloneApplication() {}

    const String getApplicationName() {
        return ProjectInfo::projectName;
    }
    const String getApplicationVersion() {
        return ProjectInfo::versionString;
    }
    bool moreThanOneInstanceAllowed() {
        return true;
    }

    bool is_first_call_back;
    //==============================================================================
    void initialise (const String&)
    {
        /*
          __arrays = new float*[FIRST_DIMENSION_SIZE];
          __target = new float*[FIRST_DIMENSION_SIZE];
          __source = new float*[FIRST_DIMENSION_SIZE];
          __tmp_array = new float[FIRST_DIMENSION_SIZE];
          for( int f1 = 0 ; f1 != FIRST_DIMENSION_SIZE ; ++f1 )
          {
              __arrays[f1] = new float[FIRST_DIMENSION_SIZE];
              __target[f1] = new float[FIRST_DIMENSION_SIZE];
              __source[f1] = new float[FIRST_DIMENSION_SIZE];
          }
          for( int f1 = 0 ; f1 != FIRST_DIMENSION_SIZE ; ++f1 )
          {
              for( int f2 = 0 ; f2 != FIRST_DIMENSION_SIZE ; ++f2 )
              {
                  __source[f1][f2] = f1*f2;
              }
          }


          int64 start_time = Time::getMillisecondCounterHiRes();
          haevy_loop_with_own_memory(__target,__source,FIRST_DIMENSION_SIZE);
          std::cout<<  "haevy_loop_with_own_memory ___ "<< start_time - Time::getMillisecondCounterHiRes() << std::endl;

          for( int f1 = 0 ; f1 != FIRST_DIMENSION_SIZE ; ++f1 )
          {
              for( int f2 = 0 ; f2 != FIRST_DIMENSION_SIZE ; ++f2 )
              {
                  __source[f1][f2] = f1*f2;
              }
          }
          start_time = Time::getMillisecondCounterHiRes();
          haevy_loop_wirting_to_static_arrays(__target,__source,FIRST_DIMENSION_SIZE);
          std::cout<<  "haevy_loop_wirting_to_static_arrays ___ "<< start_time - Time::getMillisecondCounterHiRes() << std::endl;

          for( int f1 = 0 ; f1 != FIRST_DIMENSION_SIZE ; ++f1 )
          {
              for( int f2 = 0 ; f2 != FIRST_DIMENSION_SIZE ; ++f2 )
              {
                  __source[f1][f2] = f1*f2;
              }
          }
          start_time = Time::getMillisecondCounterHiRes();
          haevy_loop_with_writing_in_a_static_tmp_array(__target,__source,FIRST_DIMENSION_SIZE);
          std::cout<<  "haevy_loop_with_writing_in_a_static_tmp_array ___ "<< start_time - Time::getMillisecondCounterHiRes() << std::endl;
        */

        Looped_array = new float[THIS_TEST_T];
        Looped_array2 = new float[THIS_TEST_T];
        Looped_array3 = new float[THIS_TEST_T];
        Looped_array4 = new float[THIS_TEST_T];
        Looped_array5 = new float[THIS_TEST_T];
        Looped_array_3 = new float*[3];
        Looped_array_31 = new float*[3];
        for( int f1 = 0 ; f1 != 3 ; ++f1 )
        {
            Looped_array_3[f1] = new float[THIS_TEST_T];
            Looped_array_31[f1] = new float[THIS_TEST_T];
            for( int i = 0 ; i != THIS_TEST_T ; ++i )
            {
                Looped_array_3[f1][i] = hidden_function_for_test_in_main(f1);
                Looped_array_31[f1][i] = Looped_array_3[f1][i];
            }

        }
        for( int f1 = 0 ; f1 != THIS_TEST_T ; ++f1 )
        {
            Looped_array[f1] = hidden_function_for_test_in_main(f1);
            Looped_array2[f1] = Looped_array[f1];
            Looped_array3[f1] = Looped_array[f1];
            Looped_array4[f1] = Looped_array[f1];
            Looped_array5[f1] = Looped_array[f1];
        }

        int64 start_time = Time::getMillisecondCounterHiRes();
#define loop_size 51200000
        for( int f1 = 0 ; f1 != loop_size ; ++f1 )
        {
            //Looped::unroll3(THIS_TEST_T,Looped_array_3);
        }
        std::cout<<  "process_noral ___ "<< start_time - Time::getMillisecondCounterHiRes() << std::endl;

        start_time = Time::getMillisecondCounterHiRes();
        for( int f1 = 0 ; f1 != loop_size ; ++f1 )
        {
            //Looped::process3(THIS_TEST_T,Looped_array_31);
        }
        std::cout<<  "process_template_v2 ___ "<< start_time - Time::getMillisecondCounterHiRes() << std::endl;


        is_first_call_back = false;

#ifndef IS_MOBILE_APP
        startTimer(5);
#endif
        String DEVEL_VERSION = getApplicationName() + String(" ") + getApplicationVersion();
#if JUCE_LINUX || JUCE_WINDOWS
        standaloneFilterWindow = new StandaloneFilterWindow(DEVEL_VERSION);
#else
        standaloneFilterWindow = new StandaloneFilterWindow(DEVEL_VERSION);
#endif
#ifndef IS_MOBILE_APP
#if JUCE_LINUX || JUCE_WINDOWS
        standaloneFilterWindow->setUsingNativeTitleBar( false );
#else
        // HERE ENABLE NATIVE MAC WINDOWS
        standaloneFilterWindow->setUsingNativeTitleBar( false );
#endif
        standaloneFilterWindow->setDropShadowEnabled( true );
#endif
#if JUCE_IOS || JUCE_ANDROID
        standaloneFilterWindow->setResizable (true, false);
#	if ! JUCE_IOS
        standaloneFilterWindow->setDropShadowEnabled( false );
#	endif
#else
        // HERE ENABLE NATIVE MAC WINDOWS
//#	ifdef JUCE_MAC
//        standaloneFilterWindow->setTitleBarButtonsRequired (DocumentWindow::minimiseButton | DocumentWindow::closeButton | DocumentWindow::maximiseButton, true );
//#	else
        standaloneFilterWindow->setTitleBarButtonsRequired (DocumentWindow::minimiseButton | DocumentWindow::closeButton | DocumentWindow::maximiseButton, false );
//#	endif
        standaloneFilterWindow->setResizable(true,true);
        //standaloneFilterWindow->ResizableWindow::resizableCorner->setAlwaysOnTop(true);
#endif
    }

    void timerCallback()
    {
        if( !is_first_call_back )
        {
            is_first_call_back = true;
            startTimer(5); // 750
        }
        else
        {
            stopTimer();
            standaloneFilterWindow->addToDesktop();
            standaloneFilterWindow->setVisible (true);
            //standaloneFilterWindow->toFront(true);
            //standaloneFilterWindow->editor->startTimer(1000.0f/30);

            standaloneFilterWindow->setEnabled(true);

            DBG( "SHOW MAINWINDOW" );
        }
    }

    void shutdown()
    {
        // Add your application's shutdown code here..
        DBG( "USR QUIT") ;

        standaloneFilterWindow = nullptr; // (deletes our window)
    }

//==============================================================================
    void suspended() override
    {
#ifdef JUCE_ANDROID
        standaloneFilterWindow->store->save_settings();
#endif
        //standaloneFilterWindow->suspended();
    }
    void resumed() override
    {
#ifdef JUCE_ANDROID
        // TODO is this required?
        standaloneFilterWindow->store->save_settings();
#endif
        //standaloneFilterWindow->resumed();
    }

    void systemRequestedQuit()
    {
        // This is called when the app is being asked to quit: you can ignore this
        // request and let the app carry on running, or call quit() to allow the app to close.
        DBG( "SYS QUIT") ;

        quit();
    }

    void anotherInstanceStarted (const String&)
    {
        // When another instance of the app is launched while this one is running,
        // this method is invoked, and the commandLine parameter tells you what
        // the other instance's command-line arguments were.
    }

private:
    ScopedPointer<StandaloneFilterWindow> standaloneFilterWindow;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (gstepstandaloneApplication)
};

//==============================================================================
// This macro generates the main() routine that launches the app.
START_JUCE_APPLICATION (gstepstandaloneApplication)








